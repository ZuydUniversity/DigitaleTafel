{"version":3,"sources":["webpack://tritra/webpack/universalModuleDefinition","webpack://tritra/webpack/bootstrap","webpack://tritra/./src/lib/TouchPoint.js","webpack://tritra/./src/lib/Vector2d.js","webpack://tritra/./src/lib/MathUtils.js","webpack://tritra/./src/lib/Triangle.js","webpack://tritra/./src/lib/Match.js","webpack://tritra/./src/lib/Recognizer.js","webpack://tritra/./src/lib/index.js"],"names":["root","factory","exports","module","define","amd","self","this","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","TouchPoint","point","_classCallCheck","groups","isPaired","Vector2d","x","arguments","length","undefined","y","Vector2d_classCallCheck","u","Math","sqrt","pow","MathUtils","v1","v2","start","end","amount","radians","PI","Triangle","p1","p2","p3","Triangle_classCallCheck","dist","distance","diff01m02","abs","diff02m12","diff01m12","a","b","middlePoint","lerp","diff","normalize","radToDeg","atan2","ab","cb","dot","cross","alpha","floor","Match","index","matchedAngle","triangle","Match_classCallCheck","getApex","getApexAngle","getCenter","getOrientation","Recognizer","apexAngles","options","Recognizer_classCallCheck","_objectSpread","maxPointDistance","maxAngleTolerance","points","touchPoints","tp","push","groupIdx","j","polygons","polygonPoints","i2","j2","polygonsUnique","exists","k","matches","apexAngle","__webpack_exports__","Recognizer_Recognizer","Triangle_Triangle"],"mappings":"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","file":"js/tritra.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"tritra\"] = factory();\n\telse\n\t\troot[\"tritra\"] = factory();\n})(typeof self !== 'undefined' ? self : this, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n","export default class TouchPoint {\n\n  // construction\n  constructor(point) {\n    this.point = point;\n    this.groups = [];\n    this.isPaired = false;\n  }\n  //----------------------------------------------------------------------------\n}\n","export default class Vector2d {\n\n  // construction\n  constructor(x = 0, y = 0) {\n    this.x = x;\n    this.y = y;\n  }\n  //----------------------------------------------------------------------------\n\n  // accessors\n  normalize() {\n\n    let u = new Vector2d(\n      this.x / Math.sqrt(Math.pow(this.x, 2) + Math.pow(this.y, 2)),\n      this.y / Math.sqrt(Math.pow(this.x, 2) + Math.pow(this.y, 2))\n    );\n\n    this.x = u.x;\n    this.y = u.y;\n  }\n  //----------------------------------------------------------------------------\n}\n","export default class MathUtils {\n\n  /**\n   * calculate the distance between two vectors\n   * @param {Vector2d} v1\n   * @param {Vector2d} v2\n   * @return {number} The distance\n   */\n  static distance(v1, v2) {\n    return Math.sqrt(\n      Math.pow(v2.x - v1.x, 2) + Math.pow(v2.y - v1.y, 2)\n    );\n  }\n\n  /**\n   * linear interpolation of two values with given increase\n   * @param {number} start\n   * @param {number} end\n   * @param {number} amount\n   * @return {number} Interpolated value\n   */\n  static lerp(start, end, amount) {\n    return (1 - amount) * start + amount * end;\n  }\n\n  /**\n   * radians to degree conversion\n   * @param {number} radians\n   * @return {number} degree value\n   */\n  static radToDeg(radians) {\n    return radians * (180 / Math.PI);\n  }\n}\n","import Vector2d from \"./Vector2d\";\nimport MathUtils from \"./MathUtils\";\n\nexport default class Triangle {\n\n  // construction\n  constructor(p1, p2, p3) {\n\n    let dist = [\n      MathUtils.distance(p1, p2),\n      MathUtils.distance(p2, p3),\n      MathUtils.distance(p1, p3)\n    ];\n\n    // identify apex\n    // (b will always be the apex)\n\n    let diff01m02 = Math.abs(dist[0] - dist[2]),\n        diff02m12 = Math.abs(dist[2] - dist[1]),\n        diff01m12 = Math.abs(dist[0] - dist[1]);\n\n    if(diff01m02 < diff02m12 && diff01m02 < diff01m12) {\n      this.a = p2;\n      this.b = p1;\n      this.c = p3;\n    }\n    else if(diff01m12 < diff01m02 && diff01m12 < diff02m12) {\n      this.a = p1;\n      this.b = p2;\n      this.c = p3;\n    }\n    else if(diff02m12 < diff01m02 && diff02m12 < diff01m12) {\n      this.a = p1;\n      this.b = p3;\n      this.c = p2;\n    }\n\n    // @TODO: throw error?\n  }\n  //----------------------------------------------------------------------------\n\n  /**\n   * Calculate orientation of triangle\n   * @return {number} orientation in degrees\n   */\n  getOrientation() {\n\n    let middlePoint = new Vector2d(\n      MathUtils.lerp(this.a.x, this.c.x, 0.5),\n      MathUtils.lerp(this.a.y, this.c.y, 0.5)\n    );\n\n    let diff = new Vector2d(this.b.x - middlePoint.x, this.b.y - middlePoint.y);\n    diff.normalize();\n\n    return MathUtils.radToDeg(Math.atan2(diff.x, diff.y)) * -1;\n  }\n\n  /**\n   * Calculate altitude of triangle\n   * @return {number} altitude\n   */\n  getAltitude() {\n\n    let middlePoint = new Vector2d(\n      MathUtils.lerp(this.a.x, this.c.x, 0.5),\n      MathUtils.lerp(this.a.y, this.c.y, 0.5)\n    );\n\n    return MathUtils.distance(middlePoint, this.b);\n  }\n\n  /**\n   * Calculate apex angle of triangle\n   * @return {number} apex angle in degrees\n   */\n  getApexAngle() {\n\n    let ab = new Vector2d(this.b.x - this.a.x, this.b.y - this.a.y);\n    let cb = new Vector2d(this.b.x - this.c.x, this.b.y - this.c.y);\n\n    let dot = (ab.x * cb.x + ab.y * cb.y); // dot product\n    let cross = (ab.x * cb.y - ab.y * cb.x); // cross product\n    let alpha = Math.atan2(cross, dot);\n\n    return Math.abs(Math.floor(alpha * 180 / Math.PI + 0.5));\n  }\n\n  /**\n   * Calculate width of triangle\n   * @return {number} width\n   */\n  getWidth() {\n    return MathUtils.distance(this.a, this.c);\n  }\n\n  /**\n   * Calculate center point\n   * @return {Vector2d} center point\n   */\n  getCenter() {\n    return new Vector2d(\n      (this.a.x + this.b.x + this.c.x) / 3,\n      (this.a.y + this.b.y + this.c.y) / 3\n    );\n  }\n\n  /**\n   * Find apex point\n   * @return {Vector2d} apex point\n   */\n  getApex() {\n    return this.b;\n  }\n}\n","export default class Match {\n\n  /**\n   * New match for triangle recognizer\n   * @param {number} index index of matched angle\n   * @param {number} matchedAngle the matched apex angle (not the actual angle!)\n   * @param {Triangle} triangle matching triangle\n   */\n  constructor(index, matchedAngle, triangle) {\n    this.index = index;\n    this.matchedAngle = matchedAngle;\n    this.triangle = triangle;\n  }\n  //----------------------------------------------------------------------------\n\n  // delegation methods for convenience\n\n  /**\n   * Find apex point\n   * @return {Vector2d} apex point\n   */\n  getApex() {\n    return this.triangle.getApex();\n  }\n\n  /**\n   * Calculate apex angle of triangle\n   * @return {number} apex angle in degrees\n   */\n  getApexAngle() {\n    return this.triangle.getApexAngle();\n  }\n\n  /**\n   * Calculate center point\n   * @return {Vector2d} center point\n   */\n  getCenter() {\n    return this.triangle.getCenter();\n  }\n\n  /**\n   * Calculate orientation of triangle\n   * @return {number} orientation in degrees\n   */\n  getOrientation() {\n    return this.triangle.getOrientation();\n  }\n  //----------------------------------------------------------------------------\n}\n","import TouchPoint from \"./TouchPoint\";\nimport Vector2d from \"./Vector2d\";\nimport Triangle from \"./Triangle\";\nimport Match from \"./Match\";\nimport MathUtils from \"./MathUtils\";\n\nexport default class Recognizer {\n\n  /**\n   * Main recognizer instance\n   * @param {number[]} apexAngles Apex angles you want to track\n   * @param {Object} options Configuration options\n   */\n  constructor(apexAngles, options = {}) {\n\n    // read options\n    this.options = {...{\n      maxPointDistance: 150,\n      maxAngleTolerance: 5\n    }, ...options};\n\n    // apex angles to identify\n    this.apexAngles = apexAngles;\n  }\n\n  /**\n   * Recognize triangle objects within a set of given points\n   * @param {Vector2d[]} points Set of points for recognizer to analyze\n   * @return {Matches[]} Array of matches\n   */\n  findMatches(points) {\n\n    // collect raw points\n    //-------------------\n\n    let touchPoints = [];\n    for(let i = 0; i < points.length; i++) {\n      let tp = new TouchPoint(points[i]);\n      tp.isPaired = false;\n      touchPoints.push(tp);\n    }\n\n\n    // find all pairs\n    //---------------\n\n    // count group index\n    let groupIdx = 0;\n\n    for(let i = 0; i < touchPoints.length; i++) {\n      for(let j = 0; j < touchPoints.length; j++) {\n\n        // no need to compare (same)\n        if(i === j) { continue; }\n\n        let tpDistance = MathUtils.distance(touchPoints[i].point, touchPoints[j].point);\n        if(tpDistance <= this.options.maxPointDistance) {\n\n          if(touchPoints[i].isPaired && touchPoints[j].isPaired) {\n            // both already paired\n            // skip points\n          }\n          else {\n            // found a new pair\n            groupIdx++;\n            touchPoints[i].groups.push(groupIdx);\n            touchPoints[j].groups.push(groupIdx);\n            touchPoints[i].isPaired = true;\n            touchPoints[j].isPaired = true;\n          }\n        }\n      }\n    }\n\n\n    // group pairs into polygons\n    //--------------------------\n\n    let polygons = [];\n\n    for(let i = 0; i < touchPoints.length; i++) {\n\n      if(touchPoints[i].groups.length > 1) {\n\n        // a point must belong to at least two pairs\n        // otherwise it will not be considered any further\n\n        let polygonPoints = [];\n\n        for(let i2 = 0; i2 < touchPoints[i].groups.length; i2++) {\n          for(let j = 0; j < touchPoints.length; j++) {\n            for(let j2 = 0; j2 < touchPoints[j].groups.length; j2++) {\n              if(touchPoints[i].groups[i2] == touchPoints[j].groups[j2]) {\n                polygonPoints.push(touchPoints[j].point);\n              }\n            }\n          }\n        }\n\n        if(polygonPoints.length > 0) {\n          polygonPoints.push(touchPoints[i].point);\n          polygons.push(polygonPoints);\n        }\n      }\n    }\n\n    // eliminate duplicates\n    //---------------------\n\n    let polygonsUnique = [];\n\n    for(let i = 0; i < polygons.length; i++) {\n\n      let polygonPoints = [];\n\n      if(polygons[i].length > 0) {\n\n        polygonPoints.push(polygons[i][0]);\n\n        for(let j = 0; j < polygons[i].length; j++) {\n\n          let exists = false;\n          for(let k = 0; k < polygonPoints.length; k++) {\n            if(polygonPoints[k] == polygons[i][j] || j == 0) {\n              exists = true;\n            }\n          }\n\n          if(exists == false) {\n            polygonPoints.push(polygons[i][j]);\n          }\n        }\n      }\n      polygonsUnique.push(polygonPoints);\n    }\n\n    // detect requested triangles\n    //---------------------------\n\n    let matches = [];\n\n    for(let i = 0; i < polygonsUnique.length; i++) {\n\n      if(polygonsUnique[i].length !== 3) {\n        // only consider triangles\n        continue;\n      }\n\n      let triangle = new Triangle(\n        polygonsUnique[i][0],\n        polygonsUnique[i][1],\n        polygonsUnique[i][2]\n      );\n\n      // calculate the apex angle\n      let apexAngle = triangle.getApexAngle();\n\n      // check if angle matches one of our requested triangles\n      for(let j = 0; j < this.apexAngles.length; j++) {\n\n        if(apexAngle > (this.apexAngles[j] - this.options.maxAngleTolerance) &&\n           apexAngle < (this.apexAngles[j] + this.options.maxAngleTolerance)\n        ) {\n          // add to matches\n          matches.push(new Match(j, this.apexAngles[j], triangle));\n        }\n      }\n\n    }\n\n    return matches;\n  }\n}","import Recognizer from './Recognizer';\nimport Triangle from './Triangle';\nimport Vector2d from './Vector2d';\nimport Match from './Match';\n\nexport { Recognizer, Triangle, Vector2d, Match };\n"],"sourceRoot":""}